---
title:  "[프로그래머스] Lv.0 조건에 맞게 수열 변환하기2"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, PROGRAMMERS-시행착오]

toc: true
toc_sticky: true
 
date: 2024-01-16
last_modified_at: 2024-01-16
---


### 문제

정수 배열 `arr`가 주어집니다. `arr`의 각 원소에 대해 값이 50보다 크거나 같은 짝수라면 2로 나누고, 50보다 작은 홀수라면 2를 곱하고 다시 1을 더합니다.

이러한 작업을 `x`번 반복한 결과인 배열을 `arr(x)`라고 표현했을 때, `arr(x) = arr(x + 1)`인 `x`가 항상 존재합니다. 이러한 `x` 중 가장 작은 값을 return 하는 solution 함수를 완성해 주세요.

단, 두 배열에 대한 "="는 두 배열의 크기가 서로 같으며, 같은 인덱스의 원소가 각각 서로 같음을 의미합니다.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 1,000,000
    - 1 ≤ `arr`의 원소의 값 ≤ 100

---

### 입출력 예

| arr | result |
| --- | --- |
| [1, 2, 3, 100, 99, 98] | 5 |

---

### 입출력 예 설명

입출력 예 #1

- 위 작업을 반복하면 다음과 같이 `arr`가 변합니다.

| 반복 횟수 | arr |
| --- | --- |
| 0 | [1, 2, 3, 100, 99, 98] |
| 1 | [3, 2, 7, 50, 99, 49] |
| 2 | [7, 2, 15, 25, 99, 99] |
| 3 | [15, 2, 31, 51, 99, 99] |
| 4 | [31, 2, 63, 51, 99, 99] |
| 5 | [63, 2, 63, 51, 99, 99] |
| 6 | [63, 2, 63, 51, 99, 99] |

- 이후로 `arr`가 변하지 않으며, `arr(5) = arr(6)`이므로 5를 return 합니다.


### 풀이

> 정수 변수인 `count`를 선언해준 뒤,
> 
> 
> 조건에 맞는 배열이 될 때까지 `count`를 1씩 증가하며 
> 
> `while`문으로 반복해준다
> 

```jsx
function solution(arr) {
    let count = 0
    let cur = [...arr]
    while(true) {
        arr = cur
        cur = arr.map(e => e >= 50 && e % 2 === 0
                      ? e / 2 
                      : e < 50 && e % 2 === 1 
                          ? e * 2 + 1 
                          : e
                     )
        if (arr.join('') === cur.join('')) break;
        count = count + 1
    }
    return count
}
```

### 시행착오

> 문제를 풀다 풀다
> 
> 
> 테스트 케이스 정답 5가 아니라 자꾸 1 또는 0만 나와서 잠시 멈추고 생각했는데
> 
> 아! 이건 재귀다! ….. ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
> 
> 재귀라 생각하고 열심히 풀었는데,, 
> 
> 반복한 결과인 `x`를 반환해줘야해서 `x` 가 함수의 인자로 들어가야하는데,
> 
> 어떤 방식으로 넣어도 문제가 풀어지지 않았다..
> 
> `c = 0` 으로 넣고, `c`만도 넣고 했지만, 
> 
> 그대로 0을 반환하거나, `undefined`가 되었다..  
> 
> 함수 인자에 배열이 없을 땐 배열을 인자로 넣어주고 사용해도 문제 없었는데,,,
> 
> 단순한 정수는 어떻게 넣는 걸까ㅎㅎㅎㅠㅠ
> 
> ```jsx
> function solution(arr, c = 0) {
>     let cur = [...arr]
>     if (arr.join('') === cur.join('')) return c
>         arr = cur
>         cur = arr.map(e => e >= 50 && e % 2 === 0
>                       ? e / 2 
>                       : e < 50 && e % 2 === 1 
>                           ? e * 2 + 1 
>                           : e
>                      )
>         c = c + 1
>     return solution(arr, c)
> }
> ```
> 
>  + 다시 풀었다..! 
> 
> 처음 주석처리한 부분의 `if` 문 위치에 넣어서 계속 틀렸고, 
> 
> `//여기로 변경` 주석처리한 부분으로 옮겼더니 너무 단순…하게 통과..
> 
> 잘 생각해봤다면ㅠㅠ 
> 
> 재귀로 되돌아왔을 때 첫 줄에 `cur`로 선언만 하는 부분이 있는데, 
> 
> 그 후에 `arr` 와 비교해봤자 절대 같을 수가 없지…😱
> 
> ```jsx
> function solution(arr, c = 0) {
>     let cur;
>     // if (arr.join('') === cur.join('')) return c
>     cur = arr.map(e => e >= 50 && e % 2 === 0
>                       ? e / 2 
>                       : e < 50 && e % 2 === 1 
>                           ? e * 2 + 1 
>                           : e
>                      )
>     // 여기로 변경
>     if (arr.join('') === cur.join('')) return c
>     return solution(cur, c+1)
> }
> ```
> 
> 또다른 시행착오는 처음 `cur`에 빈배열 또는 `Array()`로 배열을 생성했더니
> 
> 결과가 무조건 0만 나오는 걸로 고정되더라는,,
> 
> ```jsx
> function solution(arr) {
>     let count = 0
>     let cur = []
>     .
>     .
>     .
>     return count
> }
> ```
> 
> 처음 작성했던 방식 `while(arr.join('') === cur.join(''))`
> 
> 이렇게 하면, 바로 윗줄 `let cur = arr` 때문에 무조건 같다는 조건이 바로 성립되어버린다,,
> 
> 그래서 `while(true)`로 바꾸어주었다
> 
> 다 푼 후 다른사람의 풀이를 보고 참고했는데, 
> 
> 내 풀이처럼 `cur = arr` 이렇게 바로 할당해주지 않고, `cur = [-1]`로,
> 
> while문 안에도 `arr = cur`로 할당해주는게 아닌, `cur = arr`를 할당해준 후 
> 
> `arr`에 `arr.map()` 해준 내용을 할당해서 푼 것을 보았다.. 
> 
> 역시 뒤집어(?)보기도 해야한다..!
> 
> ```jsx
> function solution(arr) {
>     let count = 0
>     let cur = arr
>     while(arr.join('') === cur.join('')) {
>         arr = cur
>         cur = arr.map(e => e >= 50 && e % 2 === 0
>                       ? e / 2 
>                       : e < 50 && e % 2 === 1 
>                           ? e * 2 + 1 
>                           : e
>                      )
>         count = count + 1
>     }
>     return count
> }
> ```
> 

### 느낀 점 & 배운 점

> 재귀를 더 알아볼 필요가 있다!
> 
> 
> 이 상황에 쓸 수 있을지 없을지를 먼저 생각해볼 수 있게
> 
> 제대로 된 사용법을 숙지하자
> 
> `while` 에 넣을 조건문이 없을 경우 
> 
> `while(true)` 로 조건을 둔 후, 
> 
> 반복문이 멈추는 경우를 `break;` 로 빠져나오도록 하는 방법
> 
> 무조건 `while`의 조건에 같아지는 경우 멈추라는 식으로만 작성했는데, 
> 
> 이 문제처럼 조건이 정확한 숫자로 정해지지 않고, 수식을 써야하는 경우 
> 
> 유용하게 쓸 수 있을 것 같다! 
> 
> 그런데 다른사람의 풀이 보니,, 
> 
> 오히려 조건에 같아지는 경우까지 반복한다는 풀이 아래에 달린
> 
> ‘이렇게도 할 수 있구나’라는 댓글을 보아따,,,
>