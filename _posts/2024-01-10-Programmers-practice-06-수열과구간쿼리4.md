---
title:  "[프로그래머스] Lv.0 수열과 구간 쿼리4"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, PROGRAMMERS-문제]

toc: true
toc_sticky: true
 
date: 2024-01-10
last_modified_at: 2024-01-10
---

### 문제

정수 배열 `arr`와 2차원 정수 배열 `queries`이 주어집니다. `queries`의 원소는 각각 하나의 `query`를 나타내며, `[s, e, k]` 꼴입니다.

각 `query`마다 순서대로 `s` ≤ `i` ≤ `e`인 모든 `i`에 대해 `i`가 `k`의 배수이면 `arr[i]`에 1을 더합니다.

위 규칙에 따라 `queries`를 처리한 이후의 `arr`를 return 하는 solution 함수를 완성해 주세요.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 1,000
    - 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
    - 0 ≤ `s` ≤ `e` < `arr`의 길이
    - 0 ≤ `k` ≤ 5

---

### 입출력 예

| arr | queries | result |
| --- | --- | --- |
| [0, 1, 2, 4, 3] | [[0, 4, 1],[0, 3, 2],[0, 3, 3]] | [3, 2, 4, 6, 4] |

---

### 입출력 예 설명

입출력 예 #1

- 각 쿼리에 따라 `arr`가 다음과 같이 변합니다.

arr

---

[0, 1, 2, 4, 3]

---

[1, 2, 3, 5, 4]

---

[2, 2, 4, 5, 4]

---

[3, 2, 4, 6, 4]

---

- 따라서 [3, 2, 4, 6, 4]를 return 합니다.


### 풀이 (처음 푼 방식)

> queries를 먼저 사용할 때 `map()`을 쓰게 되면, `queries` 길이의 배열이 반환되기 때문에 꼭 `reduce()` 를 사용해서 초기값으로 `arr`를 넣어주는 방식으로 해야 했다.
> 
> 
> (꼭,, 이 방법이 정답이 아닐수도 있으나 내 수준에서..!)
> 
> 이후 숫자를 비교하는 조건과 배수 조건은 간단했..다.
> 
> 사실 간단한거긴 했으나  `? i % k === 0` 이 부분 문제를 잘못 이해해서 시행착오가 있었다🥲 (아래 설명)
> 

```jsx
function solution(arr, queries) {
    return queries
        .reduce(
        (a, [s, e, k]) => a
            .map((v, i) => s <= i && i <= e 
                 ? i % k === 0 
                    ? v = v + 1
                    : v 
                 : v)
        , arr
    )
}
```


> `arr` 먼저 반복 후, `queries` 반복으로 풀어보았다.
> 
> 
> `arr`를 먼저 반복했기 때문에 입출력 예시처럼 모든 `arr[i]` 가 1씩 증가하면서 진행되지 않고, 
> 
> 각 `arr[i]` 마다 증가할 모든 숫자가 올라간 후 다음 `arr[i]` 로 넘어가게 된다.
> 
> 대신 굉장히 효율이 안 좋았다..! 이런 숫자는 처음 봄,,,
> 
> | 테스트 10 〉 | 통과 (21.13ms, 37.2MB) |
> | --- | --- |


```jsx
function solution(arr, queries) {
		return arr
		        .map((v, i) => queries
		             .reduce((a, [s, e, k]) => s <= i && i <= e 
		                  ? i % k === 0 
		                     ? v = v + 1
		                     : a
		                  : a
		                 , v)
		            )
}
```


### 시행착오 및 느낀 점

> 문제 이해가 어려웠다
> 
> 
> 확실히 뒤로 갈수록 푸는 것보다 문제 이해하는데 걸리는 시간이 더 드는 듯..
> 
> 복잡한 문제인 경우도 있었지만 이 경우는 문제에 대한 설명이 너무 생략되어있어서 
> 
> 이걸 물어보는 건가? 싶은 부분이 많았다.
> 
> 문제에서 말하는 `i` 도 인덱스를 말하는 건지, 그러면 `queries` 와 `arr` 중 어느 인덱스를 말하는 건지, 아니면 또 그 인덱스에 해당하는 값을 말하는 건지
> 
> 실행해서 틀릴 때마다 식이 잘못된건지, 문제를 잘못 적용한건지 모르니 경우의 수가 너무 많았고, 질문하기로 통과한 분들이 문제 해설(?)😂 해둔 것을 보고 풀 수 있었다.  
> 
> 실수? 라고 하긴 그렇지만 또 하나의 의문점. 
> 
> 처음에 `v = v + 1` 을 `v++` 나, 그냥 `v + 1` 로 해보았으나, 답이 다르게 나왔다. 
> 
> 해당 위치가 `v`의 값이니 그냥 할당해주지 않고, 
> 
> 숫자를 올려주기만 해도 똑같은 결과일거라 생각했는데, 아니었다는,,, 
> 
> 이 부분도 이유가 뭔지 알아봐야함
> 
> (`v++`는 정답보다 각 1씩 숫자가 적었는데, )
> 
> 아마도 그냥 값을 증가만 시켜주면 reduce 함수의 누적되는 역할을 못한게 아닐까라고 추측만,,
> 
> 실수한 점 
> 
> `queries` 를 먼저 돌아보기도 하고, `arr` 를 먼저 돌아보기도 했는데, 자꾸 틀려서 그 문제는 아닌 것 같아 설마,,, 설마,,, 하면서 봤더니..! 
> 
> `i` 가 `k` 의 배수인지 확인해야 하는데, 예시에 있는 `k` 가 크다보니 나도 모르게 
> 
> `k % i === 0` 으로 조건을 걸고 있었던 것..!!! 
> 
> 이런ㅜㅠㅠ 
> 
> 이 부분만 바꿔줬더니 너무나 간단하게.. 통과…😇
> 


### 느낀 점 & 배운 점

> 문제의 조건을 잘 확인해야 한다! 예시의 케이스에 현혹(?) 되지 말고
> 
> 
> 문제에 맞는 조건을 입력하자! 
> 
> 0도 모든 숫자의 정수! 그래서 0번째 인덱스의 값은 계속 1씩 숫자가 더해졌다! 
>