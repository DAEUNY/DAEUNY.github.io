---
title:  "[프로그래머스] Lv.0 수열과 구간 쿼리1"
excerpt: ""

categories:
  - TIL
tags:
  - [TIL, PROGRAMMERS-문제]

toc: true
toc_sticky: true
 
date: 2024-01-09
last_modified_at: 2024-01-09
---


### 문제

정수 배열 `arr`와 2차원 정수 배열 `queries`이 주어집니다. `queries`의 원소는 각각 하나의 `query`를 나타내며, `[s, e]` 꼴입니다.

각 `query`마다 순서대로 `s` ≤ `i` ≤ `e`인 모든 `i`에 대해 `arr[i]`에 1을 더합니다.

위 규칙에 따라 `queries`를 처리한 이후의 `arr`를 return 하는 solution 함수를 완성해 주세요.

---

### 제한사항

- 1 ≤ `arr`의 길이 ≤ 1,000
    - 0 ≤ `arr`의 원소 ≤ 1,000,000
- 1 ≤ `queries`의 길이 ≤ 1,000
    - 0 ≤ `s` ≤ `e` < `arr`의 길이

---


### 입출력 예

| arr | queries | result |
| --- | --- | --- |
| [0, 1, 2, 3, 4] | [[0, 1],[1, 2],[2, 3]] | [1, 3, 4, 4, 4] |

---


### 입출력 예 설명

입출력 예 #1

- 각 쿼리에 따라 `arr`가 다음과 같이 변합니다.

| i | queries[i] | arr |
| --- | --- | --- |
| - | - | [0, 1, 2, 3, 4] |
| 0 | [0,1] | [1, 2, 2, 3, 4] |
| 1 | [1,2] | [1, 3, 3, 3, 4] |
| 2 | [2,3] | [1, 3, 4, 4, 4] |


- 따라서 [1, 3, 4, 4, 4]를 return 합니다.


### 풀이


> 
> 
> 와... 문제를 잘못 이해했네..
> 1이 커지는 걸 arr[i]의 숫자가 [s, e]의 사이에 있을 때로 이해해서
> 온갖 이렇게 해당하는 수식을 썼는데 무슨 코드 실행만 통과하고
> 제출하면 하나도 안맞고 실패...
> 다시 보니... index를 말하는게 아니라... 회차?
> 각 i 회차마다 [s, e]에 해당하는 위치에 있는 arr의 요소를 1씩 더한다고 이해하고
> 다시 풀어보자... 하...
> 
> 두번째 낚임(?)
> 
> 예시가 하나밖에 없고 테스트케이스를 볼 수 없으니.. queries가 전부 1씩 차이나는 숫자인줄 알고 수기로 딱 [s, e] 2개만 1씩 증가 해줬는데
> 
> 예시에 있는 그대로 코드 테스트를 하니 실행은 되고 또 제출은 다 틀린 것,,,,
> 
> 문제를 다시 꼼꼼히 보고 결국 반복문으로 [s, e] 사이의 모든 위치에 해당하는 arr의 숫자를 1씩 증가해줬더니 맞았음…
> 
> 하… 이런 문제는 문제 설명과 예시만 보고는 뭘 구하라는 문제인지 알기가 너무 어렵다ㅠㅠ
> 
> 뭘 구하는지 정확히 파악 못하고 있으니 삽질만…
> 
> 수열과 구간 쿼리 시리즈(?) 몇 개 더 있던데,, 제대로 풀 수 있길ㅠㅠㅠㅠ
> 
> 시간이 지나고 다시 돌아보면 이 문제는 아무것도 아니길,,,ㅎㅎ😂

### 풀이

정답

```jsx
function solution(arr, queries) {
    queries.map(([s, e]) => {
        for(let i = s; i <= e; i++) {
            arr[i]++
        }
    })
    return arr
}
```


### 시행착오 (a.k.a 틀린 풀이)
>
```jsx
function solution(arr, queries) {
    
    // 틀림
    // for (let el of arr) {
    //     for (let q of queries) {
    //         q[0] <= el && el <= q[0] ? el = el + 1 : el = el
    //     }
    // }
    // return arr

    queries.map(([s, e]) => {
        arr[s] += 1
        arr[e] += 1
    })
    return arr
    
    // return arr
    //     .map((v, i) => queries
    //          .reduce((a, c) => c[0] <= v && v <= c[1] 
    //                  ? a + 1 
    //                  : a
    //                  , v
    //                 )
    //         )
    
    // return arr.map((v, i) => queries
    //            .map((q) => q[0] <= v && v <= q[1] 
    //                 ? arr[i] += 1
    //                 : arr[i]
    //            )
    //         ).map(e => e[e.length-1])

}
```